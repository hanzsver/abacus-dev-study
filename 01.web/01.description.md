# 개요

```
웹 기술을 사실 굉장히 단순하다. 서버 또는 클라이언트에 hmtl, javascript, css를 브라우저가 해석 할 수 있도록 정의하고 사용자가 공개된 주소(도메인)을 통해 접근하면 의도한 페이지를 볼 수 있다. 이게 전부이다.

하지만 우리는 보다 나은 발전된 기술을 통해 사용자에게 서비스를 제공하기 위해 현대에서는 프로그래밍 환경, 기술들이 고도화 되면서 특정 목적에 의해 기술들이 정의되고 있고, 파생에 파생을 이어가고 있다.
특정 목적은 개발의 생산성, 타 플랫폼과의 연동, 임베디드 기기와의 통신, AI, 빅데이터, 그 외 특정 엔지니어링들이 있을 수 있다.

빠르게 발전하는 웹기술에서 우리는 적절한 기술들을 선택하고 학습하며 익술해지는 과정에서 원활히 소통하는 방법을 훈련 하도록 하자.

우리는 서로 무수한 관점에서 서로에게 질문을 던지고 답하며 서로 다르게 정의 될 수 있는 기술들을 준수히 공통화 될 수 있고 나아가 분업된 협업에서 원환한 소통을 통해 보다 나은 결과물을 낼 수 있을 것이라 기대한다.
```

# 웹의 구성 요소

> 웹의 구성 요소를 키워드로 정리 해보자.

- **Web Client (Web browser)**

  - 웹 서버에 접속해 HTML/CSS/JS 를 해석하여 웹페이지를 렌더링해 주는 소프트웨어
  - 종류
    - Edge
    - Safari
    - Chrome
    - Firefox
    - Other Browser...
  - 무료로 사용할 수 있는 이유?
    - Web browser는 rfc 규격을 지켜 마켓팅을 위해 만들어진 프로그램이기 때문이다.

  * 다크웹?
    - 일반적인 접근이 불가능한 웹이며 브라우저가 서버 역할을 함
      ip등이 비밀리에 숨겨져 있고 불법거래가 주 컨텐츠, 추적이 불가능
      세계에서 대한민국이 다크웹 점유율 1위(넘사벽)
      이유는 대한민국에 인터넷 속도가 다른 나라보다 월등히 빠르기 떄문!

---

- **Web Server**

  - 클라이언트에서 요청을 받아 응답을 보내는 컴퓨터 시스템/소프트웨어
  - 클라이언트 요청에 따라 웹페이지, 이미지, 파일, 데이터베이스 제공
  - HTTP 프로토콜을 이용하여 클라이언트의 요청을 서버에 전달
  - 종류

    - Apache:
      웹 서버용 소프트 웨어(HTTP 웹 서버) 아파치는 많은 운영체제에서 운용 할 수 있다.
      세계에서 가장 많이 쓰는 웹 서버중 하나로 서버가 굉장히 다양하고
      기능적인 면에서 우수하고 구축이 쉽다.
      단, 무겁고 slowloris 취약점이 있다.
      웹서버로 불리며 클라이언트 요청이 왔응때만 응답하는
      정적 웹페이지에 사용(HTML, CSS, 이미지 등 정적인 데이터만 처리)
      80 포트로 처리한다.
    - Tomcat:
      tomcat은 흔히 WAS(Web Application Server) 라고 말한다.
      동적인 웹을 만들기 위한 웹 컨테이너, 서블릿 컨테이너라고 불리며,
      웹서버에서 정적으로 처리해야할 데이터를 제외한 JSP, ASP, PHP 등은
      웹 컨테이너(톰캣)에게 전달한다.
      동적인 데이터 처리가 가능하고, DB 연결, 데이터 조작,
      다른 응용프로그램과 상호 작용이 가능
      8080 포트로 처리한다.
    - Node: JavaScript로 서버 측 코드를 실행할 수 있는 서버의 역할을 수행.

    > JSP : JavaSErver Page
    > HTML 코드에 JAVA 코드를 넣어 동적 웹페이지를 생성하는 웹어플리케이션(WAS) 도구
    >
    > 자바 서블릿
    > 서블릿이란 웹페이지를 동적으로 생성하기 위한 서버측 프로그램
    > 자바 언어를 기반으로 만들어지면 WAS 위에서 컴파일되고 동작된다.
    >
    > 아파치 로드 벨런싱
    > 하나의 서버에서 감당할수 있는 한계점이 존재 하는데
    > 접속 중간지역에서 웹서버에 적절히 분할을 해주면서
    > 리소스를 효율적으로 구성, 톰캣과 연동이 가능
    >
    > slowloris
    > HTTP Header 정보를 비정상적으로 조작하여 웹서버가
    > 온전한 Header정보가 올때 까지 기다리도록 한다.
    > 서버가 연결 상태를 유지할 수 있는 가용자원은 한계가 있으므로
    > 임계치를 넘어가면 다른 정상적인 접근을 거부하게 된다.

---

- **HTTP, HTTPS**

  - **HTTP (Hypertext Transfer Protocol):** HTTP란 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜(통신규약). 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로. 80번 포트를 사용한다.
  - **HTTPS (Hypertext Transfer Protocol Secure):** HTTPS는 HTTP에 데이터 암호화가 추가된 프로토콜
    443번 포트를 사용하며, 중간에 제3자가 볼 수 없도록 암호화를 지원
  - **HTTP와 HTTPS의 차이:** 인증서와 공개키. 공개키로 암호화된 데이터를 해석

---

- **API**

  - Application Programming Interface
  - 프로그램들이 서로 상호작용하는 것을 도와주는 매개체
  - 서버와 데이터베이스에 대한 출입구 역할
  - 종류

    - SOAP: 웹 서비스 간 통신을 위한 프로토콜. 단순 객체 접근 프로토콜을 사용. 클라이언트와 서버는 XML을 사용하여 메시지를 교환 과거에는 더 많이 사용되었으며 유연성이 떨어짐
      - xml
    - REST: Representational State Transfer는 클라이언트가 서버 데이터에 엑세스하는데 사용할 수 있는 GET. PUT, DELETE 등의 함수 집합을 정의.
      - json

    > [ xml ]
    >
    > w3c에서 개발된 다목적 마크업 언어
    > html 과 동일
    > tag 안에 속성과 데이터를 만들어서 전달
    > **`<product>`** > **`<id>`**50** `</id>`** > **`<name>`**samsung** `</name>`** > **`<category>`**computer** `</category>`** > **`<price>`**1500000** `</price>`** > **`</product>`**
    >
    > **`<!-- 속성 표현 -->`** > **`<product id="50" name="samsung" category="computer" price="1500000">`** > **`</product>`**
    >
    > [ json ]
    > JavaScript Object Notation(JSON)은
    > Javascript 객체 문법\*\*으로 구조화된 데이터를 표현하기 위한
    > 문자 기반의 표준 포맷. 데이터를 전송할 떄 일반적으로 사용
    >
    > ```
    > "members":
    > [
    > {
    > "name": "Molecule Man",
    > "age": 29,
    > "secretIdentity": "Dan Jukes",
    > "powers": ["Radiation resistance", "Turning tiny", "Radiation blast"]
    > }
    > ]
    > ```

---

- **Web Application**

  - 개발을 위한 라이브러리.
  - 브라우저 등을 통해 접근할 수 있는 응용프로그램. HTTP에서 동작

    ```
    [웹 어플리케이션의 역사와 발전]

    인터넷이 발달하기 전에는 소프트웨어를 사용하기 위해서 물리적인 유통이 필요했다.
    (CD로 설치하는 windows, 게임 등)

    1세대 웹 서비스
    	1세대 웹사이트는 모두 정적(static)인 웹사이트
    	HTML은 로직이 존재하지 않는 마크업 언어이기 때문에 기존에 작성된 화면만 표시

    2세대 웹 서비스
    	넷스케이프사에서 JavaScript를 개발하였고,
    	JavaScript를 활용한 동적(Dynamic)인 브라우저가 처음 생성
    	그러나 여전히 JavaScript 보다는 HTML,CSS가 주를 이뤘고,
    	JavaScript는 그 위에 살짝 얹혀진 느낌이었다.

    3세대 웹 서비스
    	동적인 요소가 점점 더 중요시 되면서 HTML,CSS보다
    	JavaScript 위주로 코드가 작성되기 시작하면서
    	3세대 부터 Single Page Application = SPA 라는 개념이 등장
    	이로 인해 UI / UX를 담당하는 부분
    	프론트엔드와 백엔드의 경계가 명확하게 나뉘어지게 되고
    	엄청난 동시 접속자 수와 방대한 Data의 양때문에 웹사이트가 매우 복잡하고 정교해짐
    ```

- - HTML: 웹 페이지의 구조를 정의하는 마크업 언어.
  - Responsive Design (반응형)
  - Adaptive Design (적응형)
  - |                | 반응형                                                      | 적응형                                          |     |
    | -------------- | ----------------------------------------------------------- | ----------------------------------------------- | --- |
    | 기기/화면 감지 | 미디어 쿼리로 기기 감지                                     | 서버 또는 브라우저에서 기기 감지                |     |
    | 템플릿         | 하나의 템플릿                                               | 기기마다 다른 템플릿 필요                       |     |
    | 콘텐츠         | 모든 콘텐츠 다운로드                                        | 기기별 콘텐츠만 다운로드                        |     |
    | 장점           | 일관성있는 uiux 제공, 다양한 기기 대응                      | 적은 데이터 낭비, 빠른 로딩 속도                |     |
    | 단점           | 디자인-개발-테스트 시 드는 많은 시간과 비용, 느린 로딩 속소 | 기기별 별도 유지보수 요구, 일관되지 않은 데이터 |     |
- JavaScript

  - ES6 (ECMAScript 2015): JavaScript의 표준 버전 중 하나로, 확장된 기능을 제공.
  - Framework: 웹 애플리케이션을 구축하기 위한 자바스크립트 프레임워크 및 라이브러리.
    - react
    - vue
    - angular
    - angularJS
  - Typescript:

- CSS

  - Sass, SCSS: CSS의 확장으로, 스타일 시트를 더 효율적으로 작성할 수 있게 함.

    ```
    [ SASS ]
    sass는 컴파일 과정을 통해 css 파일을 생성해주는 css 확장 언어이자 전처리기
    (컴파일 하기 전에 소스 파일을 처리하는 컴파일러의 한 부분, 자신만의 특별한 구문을 가지고 CSS를 생성하도록 하는 프로그램)이다. css 대체 언어는 아니고 확장언어이며 css 코드를 생산해내기 위해 사용하는 일종의 도구

    특징
    호환성, 기능성, 안정성, 인지도, 신뢰도, 확장성

    [ SCSS ]
    scss-Syntactically Awesome StyleSheet는
    css와 완전히 호환되도록 새로운 구문을 도입한 css 상위 호환 스타일이다.
    sass 기능을 지원하되, 중괄호+세미클론을 사용하는 등 css와 거의 같은 문법형식이다.
    ```

- SPA (Single Page Application): 페이지를 새로 로드하지 않고 동적으로 업데이트하는 웹 애플리케이션.
- Rendering

  - SSR (Server-Side Rendering): 서버에서 웹 페이지의 초기 렌더링을 수행.
  - CSR (Client-Side Rendering): 클라이언트 측에서 자바스크립트를 사용하여 동적으로 페이지를 렌더링.

- Database

  - DBMS (Database Management System): 데이터베이스를 관리하는 소프트웨어.
  - O-DBMS (Object Database Management System): 객체 지향 데이터베이스를 관리하는 시스템

---

- 쿠키, 세션

  - 클라이언트와 서버 간 상태 유지
  - 사용자 정보 저장

---

- 웹 호스팅 및 클라우드 서비스

  - AWS, Google Cloud

---

- 웹 보안

  - SSL/TLS, CORS, CSP

---

- 웹 소켓

  - 실시간 양방향 통신 프로토콜
  - 채팅

---

> Q. 웹서버의 역할을 서술 해보자.

```
A. 웹 브라우저 클라이언트로부터 HTTP 요청을 받아들이고 콘텐츠를 제공함
즉 HTTP 프로토콜을 이용 클라이언트의 GET, POST 등의 메소드를 활용한 요청을 서버에 전달하고 이를 서버라는 또 다른 컴퓨터가 그 요청을 처리하여 다시 클라이언트에게 전달해주는 작업이라고 볼 수 있다.
```

---

> Q. API는 무엇이고 왜 구성되게 되었을까 서술해보자.

```
A.
API: 소프트웨어 응용 프로그램 간에 상호 작용할 수 있도록 하는 인터페이스.

1. 응용 프로그램의 기능을 재사용함으로써 개발에 소요되는 시간, 비용 절감
2. 새로 개발할 필요없이 이미 만들어진 API를 사용함으로써 유연성, 확장성 향상
3. 보안 강화 목적
```

---

> Q. 웹서버의 역할과 웹클라이언트의 역할을 구분하고, 각 위치에는 어떤 것들이 구성 될 수 있는지 알아보자.

```
A. 웹 서버는 웹 페이지를 제공하는 역할을 하며, 웹 클라이언트는 웹 페이지를 웹 서버로부터 받아 볼 수 있게 해주는 역할을 한다.

#### A. 구성 요소
#### server : server-side programing language(php, java, c# ...), html, css, javascript

#### client : html, css, javascript
```

![1701259660522](image/abucus-tutoring/1701259660522.png)

> +. html, css, javascript는 서버에도 있을 수 있고 클라이언트에도 있을 수 있다. 이유는 무엇이고 차이점은 무엇인가?

```
서버에 있는 HTML, CSS, JS 는 이를 통해 웹 페이지를 생성하며, 클라이언트에 있는 HTML, CSS, JS 는 생성된 웹 페이지를 화면에 표시한다.

SSR의 방식일 때는 서버에 있고 CSR일 떄는 클라이언트에 있습니다. 이는 렌더링 방식의 차이로 서버에서 html을 형성하는지, 브라우저에서 웹 페이지를 생성해 서버로 요청하는지에 대한 차이가 있습니다.
```

---

> Q. 자바스크립트 규격은 ECMA Script는 es6 버전부터 페러다임적 변화가 있었다. es6 전과 후의 버전은 무엇이 달라졌는지 서술해보자.

```
A.
**let, const 키워드의 추가**: 블록 스코프(지역선언) 변수와 상수의 추가
**화살표 함수의 추가** : 함수를 더 간결하게 작성할 수 있게 합니다.
**클래스 문법이 도입**
**템플릿 리터럴:** 변수나 표현식을 ${} 안에 삽입하여 문자열을 동적으로 구성할 수 있습니다.
**비동기 프로그래밍 (Promises, async/await) 도입** :Promise는 비동기 작업을 다루기 위한 객체로 대기, 이행, 거부 세가지 상태가 있다.
async는 비동기로 작동할 수 있게 해주는 문법이며 await는 비동기작업이 완료될 때까지 기다렸다가(어떤 작업이 끝나야 실행되는지) 실행하도록하는 기능입니다
**import, export, finally  추가**
```

---

> Q. 웹의 랜더링 방식은 크게 SSR과 CSR로 구분된다. 각 랜더링 방식에 대해 특징을 이해하고 서술해보자.

```
A.
SSR = 서버 사이드 렌더링. 서버에서 웹 페이지 생성 후 클라이언트에 전송. MPA에서 사용되는 방식. 완성된 HTML을 서버가 사용자 요청 시마다 즉시 만들어 보여줌.
초기 로딩 속도가 빠르고, 페이지 이동 속도가 느림. SEO에 유리하지만, 동적인 웹 페이지를 구현하기 어렵고, 리소스 사용량이 많음.
ttv와 ttl의 간극이 있음

CSR = 클라이언트 사이드 렌더링. 클라이언트에서 웹 페이지 생성. SPA에서 사용되는 방식. 자바스크립트를 이용해 사용자의 화면에서 HTML을 렌더링하여 보여줌.
동적인 웹 페이지를 구현하기 쉽고, 리소스 사용량이 적지만, 초기 로딩 속도가 느리고, SEO에 불리. 페이지 이동 속도는 빠름.
ttv와 tti의 간극이 없음

* ttv : time to view 사용자가 보는 시점
* tti : time to interact 사용자가 인터랙션 하는 시점

```

---

> Q. SPA란 무엇이고 어떤 특징을 가지고 있고 어떤 역할을 하는지 서술해보자.

```
A.
Single Page Application
단일 페이지로 구성된 웹 어플리케이션.
즉 하나의 HTML에서 페이지가 그려지는 것. 사용자의 요청에 따라 특정 부분만 갈아끼워 보여주는 형태

역할 : UX 향상 및 성능 개선, 효율적인 개발 및 유지보수(새로고침이 필요없어 페이지 상태 추적, 유지 관련 코드도 줄어듬)
```

---

> Q. 오랜 해 동안 데이타 베이스는 R-DBMS만이 사용 되어 왔다. 현재에 이르러서는 객체지향 개발론, 데이터 구조론의 고도화됨에 따라 R-DBMS는 프로그래밍 언어와의 구조적 이질감에 효율적 사용에 많이 논의 되어 왔다. R-DBMS가 프로그래밍 언어들과 어떤 구조적 차이가 있는지 서술 해보자.

```
A.
1. 세분성(Granularity)

데이터베이스의 테이블수 보다 더 많은 클래스 객체 모델이 있을 수 있기 때문에 생기는 불일치 문제 객체 모델이 관계형 모델보다 더 세분화되어있기 때문입니다.

2. 상속성(Inheritance)

관계형 데이터 베이스에 상속의 개념이 없어 생기는 불일치 문제입니다.
단순히 데이터 베이스 칼럼과 클래스 필드를 매칭 하는 것은 간단합니다.하지만 상속, 연관 등이 사용되면 객체와 테이블을 매칭 하는 것이 굉장히 복잡해집니다. (많은 테이블을 조인해야 하는 경우가 다반사)

3. 동일성(Identity)

관계형 데이터베이스는 기본키(Primary Key, PK)를 이용해 동일성을 정의하지만, 객체 식별과, 객체 동일성을 모두 고려하는 경우가 있어 생기는 불일치 문제입니다.
 관계형 데이터 베이스에서는 기본키가 동일하다면 같은 레코드로 정의하지만, JAVA에서는 주소 값이 같거나 내용이 같은 경우를 모두 고려해 정의하는 것을 예로 들 수 있습니다.

4. 연관성(Associations)
관계형 데이터 베이스에서는 외래 키(Foreign Key, FK)를 사용해 양방향 참조를 정의할 수 있으나 객체 지향 언어의 객체 참조는 단반향 참조로만 이루어지기 때문에 오는 불일치 문제입니다.
객체 지향 언어의 경우 양방향을 참조를 위해서는 양쪽 객체에 모두 연관을 정의해야 해야 합니다.

5. 탐색(Navigation)

데이터를 탐색하는 방법이 다르기때문에 오는 불일치 문제입니다.
관계형 데이터 베이스는 SQL을 최소화하기위해 조인(JOIN)을 통해 여러 엔티티(데이터집합)을 불러와서 데이터를 탐색합니다. 하지만 객체지향언어 자바의 경우 하나의 객체에서 출발해 연결을 따라 그래프 형태로 탐색을 합니다. 따라서 관계형 데이터 베이스의 경우 검색하고자 하는 테이블과 멤버가 있는지 확인을 하고 사용해야하는 제약이 있습니다.
```

---

> Q. 현대에 R-DBMS를 대체할 O-DBMS는 무엇이고 어떤 구조를 가지고 있는지 서술 해보자.

```
A.
json과 똑같은 구조
collection document(오브젝) collection(배열)
O-DBMS (객체 지향 데이터베이스 관리 시스템)은 객체 지향 모델을 기반으로 데이터를 저장, 관리 하는 시스템

1. 객체 자향 모델

데이터를 객체로 표현, 관계를 모델링한다.
개체는 속성과 메서드를 가지며, 상속 등의 객체 지향 개념을 활용

2. 복잡한 데이터 타입지원

다양한 데이터 구조를 표현 할 수 있다. 관계형 데이터 베이스의 테이블과 열에 비해 유연성이 있다

3. 질의 언어
OQL 과 같은 쿼리 언어를 제공 한다.
쿼리 언어를 제공 한다 .
4. 성능 향상

객체 간의 복잡한 관계를 효과적으로 다룰수 있고, 특정 응용 프로그램에서는 성능 향상을 가져올 수 있다.

5. 트랜잭션 지원

데이터베이스 트랜잭션을 지원하여 데이터 일관성을 보장

6. 비정형 데이터 지원

비정형 데이터나 복잡한 데이터 구조를 유연하게 다룰 수 있다.
객체 지향 데이터베이스는 객체 지향 프로그래밍 언어와 통합이 뛰어나며, 소프트웨어 개발에서
객체 지향적인 접근 방식을 따를 떄 이점을 제공한다.
```

---

# NodeJS의 이해

- Reference

1. [NodeJS 소개](https://nodejs.org/en/learn/getting-started/introduction-to-nodejs "NodeJS 소개")
2. [Node.js를 설치하는 방법](https://nodejs.org/en/learn/getting-started/how-to-install-nodejs "Node.js를 설치하는 방법")
3. [Node.js를 사용하려면 얼마나 많은 JavaScript를 알아야 합니까?](https://nodejs.org/en/learn/getting-started/how-much-javascript-do-you-need-to-know-to-use-nodejs "Node.js를 사용하려면 얼마나 많은 JavaScript를 알아야 합니까?")
4. [ECMAScript 2015(ES6)](https://nodejs.org/en/learn/getting-started/ecmascript-2015-es6-and-beyond "ECMAScript 2015(ES6)")
5. [NPM 패키지 관리자 소개](https://nodejs.org/en/learn/getting-started/an-introduction-to-the-npm-package-manager "NPM 패키지 관리자 소개")
6. [Node.js, 개발과 프로덕션의 차이점](https://nodejs.org/en/learn/getting-started/nodejs-the-difference-between-development-and-production "Node.js, 개발과 프로덕션의 차이점")
7. [TypeScript를 사용한 Node.js](https://nodejs.org/en/learn/getting-started/nodejs-with-typescript "TypeScript를 사용한 Node.js")
8. [Node.js에서 환경 변수를 읽는 방법](https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs "Node.js에서 환경 변수를 읽는 방법")

- NODE 환경에서 NPM(Node package manager) 저장소에 있는 모듈이 개발환경(local)에 저장되는 과정
  `<img src="./img/node_npm_registry_flow.PNG" width="100%" title="node_npm_registry_flow" alt="node_npm_registry_flow"/>`
- Javascript framework rank - 2023
  `<img src="./img/javascript_framework_rank_2023.png" width="100%" title="javascript_framework_rank_2023" alt="javascript_framework_rank_2023"/>`

```
단일 프로세스
	JavaScript를 실행하기 위해서는 웹 브라우저가 필수이다.
	이 단점을 보완하기 위해 node.js를 사용한다.
	node.js를 설치하게 되면 브라우저 없이 바로 실행할 수 있다.
	Reby, Java 등의 언어가 불필요하다.
	싱글 스레드, 자바스크립트 코드가 동시에 실행될 수 없다.

* 런타임
  특정 언어로 만든 프로그램을 실행할 수 있는 환경
  컴퓨터가 프로그래밍 언어를 바로 이해할 수 없기 때문에 기계어로 변환하는 과정

> 런타임 에러: 문맥적, 메모리적 요소, 쉽게 찾을 수 없는 에러

* 블로킹
  `I/O`  가 동작되는 동안에 다른 일을 처리하지 못하는 상태,
  함수가 마무리 될 때까지 다음 처리가 되지 않음
* 논 블로킹
  `I/O` 가 동작을 하면서 요청을 받으면 다음 처리에 요청을 보내놓고
  선 요청작업이 끝나면 이벤트를 받아 응답
```
