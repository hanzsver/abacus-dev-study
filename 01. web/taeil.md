# abucus-tutoring

1. 웹의 구성 요소
    - 추가적인 요소가 있다면 추가 작성
2. 서술 및 질의란
    - 각자 답변 기술
3. NodeJS 링크 래퍼런스 영역
    - 공식 문서 모두 회독 후 각자 질문 5개 이상 생성

# 개요

```
웹 기술을 사실 굉장히 단순하다. 서버 또는 클라이언트에 hmtl, javascript, css를 브라우저가 해석 할 수 있도록 정의하고 사용자가 공개된 주소(도메인)을 통해 접근하면 의도한 페이지를 볼 수 있다. 이게 전부이다.

하지만 우리는 보다 나은 발전된 기술을 통해 사용자에게 서비스를 제공하기 위해 현대에서는 프로그래밍 환경, 기술들이 고도화 되면서 특정 목적에 의해 기술들이 정의되고 있고, 파생에 파생을 이어가고 있다.
특정 목적은 개발의 생산성, 타 플랫폼과의 연동, 임베디드 기기와의 통신, AI, 빅데이터, 그 외 특정 엔지니어링들이 있을 수 있다.

빠르게 발전하는 웹기술에서 우리는 적절한 기술들을 선택하고 학습하며 익술해지는 과정에서 원활히 소통하는 방법을 훈련 하도록 하자.

우리는 서로 무수한 관점에서 서로에게 질문을 던지고 답하며 서로 다르게 정의 될 수 있는 기술들을 준수히 공통화 될 수 있고 나아가 분업된 협업에서 원환한 소통을 통해 보다 나은 결과물을 낼 수 있을 것이라 기대한다.
```

# 순서

```
1장. 웹의 구성요소들에 대해 정의하고 개념을 확립하자.
2장. Node를 알아보자.
3장. ...
```

# 웹의 구성 요소

> 웹의 구성 요소를 키워드로 정리 해보자.
> 
- **HTTP, HTTPS:**
    - **HTTP (Hypertext Transfer Protocol):** 웹에서 정보를 주고받을 수 있게 하는 프로토콜. 주로 포트 80을 사용.
    - **HTTPS (Hypertext Transfer Protocol Secure):** HTTP의 보안 버전으로, 데이터를 암호화하여 안전한 통신을 제공. 주로 포트 443을 사용.
- **Web Server:**
    - **Apache:** 오픈 소스 웹 서버로, 정적 파일과 동적 콘텐츠를 제공하는 데 사용됨.
    - **Tomcat:** Apache Tomcat은 Java Servlet 및 JavaServer Pages 기술을 구현하는 웹 애플리케이션 서버.
    - **Node:** JavaScript로 서버 측 코드를 실행할 수 있는 ~~런타임 환경~~ 서버의 역할을 수행.
    
- **Web Client (Web Browser):**
    - **Edge, Safari, Chrome, Firefox:** 웹 브라우저로, 사용자가 웹 페이지를 조회하고 상호작용할 수 있게 함.
- **API:**
    - **SOAP (Simple Object Access Protocol):** 웹 서비스 간의 통신을 위한 프로토콜. 데이터 포맷으로 XML 사용.
    - **REST (Representational State Transfer):** 아키텍처 스타일로, HTTP를 통해 자원을 조작하기 위한 인터페이스. 데이터 포맷으로 주로 JSON 사용.
- **Web Application:**
    - **HTML (Hypertext Markup Language):** 웹 페이지의 구조를 정의하는 마크업 언어.
        - **Responsive Design:** 다양한 화면 크기에 대응하여 웹 페이지를 자동으로 조정하는 디자인.
        - **Adaptive Design:** 특정 화면 크기에 맞게 웹 페이지를 조정하는 디자인.
- **JavaScript:**
    - **ES6 (ECMAScript 2015):** JavaScript의 표준 버전 중 하나로, 확장된 기능을 제공.
    - **Framework:**
        - **React, Vue, Angular, AngularJS:** 웹 애플리케이션을 구축하기 위한 자바스크립트 프레임워크 및 라이브러리.
    - **TypeScript:** 정적 타입 언어인 TypeScript는 JavaScript에 타입을 부여하여 개발 생산성을 높임.
- **CSS:**
    - **Sass, SCSS:** CSS의 확장으로, 스타일 시트를 더 효율적으로 작성할 수 있게 함.
- **SPA (Single Page Application):** 페이지를 새로 로드하지 않고 동적으로 업데이트하는 웹 애플리케이션.
- **Rendering:**
    - **SSR (Server-Side Rendering):** 서버에서 웹 페이지의 초기 렌더링을 수행.
    - **CSR (Client-Side Rendering):** 클라이언트 측에서 자바스크립트를 사용하여 동적으로 페이지를 렌더링.
- **Database:**
    - **DBMS (Database Management System):** 데이터베이스를 관리하는 소프트웨어.
    - **O-DBMS (Object Database Management System):** 객체 지향 데이터베이스를 관리하는 시스템.

> Q. API는 무엇이고 왜 구성되게 되었을까 서술해보자.
> 

```
A. 
**API란?**
Application Programming Interface의 줄임말로 두 개의 서로 다른 시스템이 서로 통신하고 데이터를 주고받을 수 있도록 도와주는 도구라고 볼 수 있습니다.

**사용 이유(구성이유)**
- **모듈화와 재사용성** : 서버에서 특정 기능(정보)을 API로 제공하면, 다양한 클라이언트 (웹 앱, 모바일 앱, 다른 서버 등)에서 동일한 기능을 사용할 수 있습니다.
- **보안 및 권한 관리** : 데이터에 대한 접근을 제어하고 보안을 강화할 수 있는 수단을 제공합니다. 인증 및 권한 부여 메커니즘을 통해 특정 사용자 또는 시스템이 허가된 기능에만 접근할 수 있도록 할 수 있습니다.
**- 서비스 확장성** : 새로운 기능을 추가하거나 기존 기능을 개선할 때, 클라이언트 측에서는 API의 변경만으로도 새로운 기능을 활용할 수 있습니다.(데이터를 가공할 수 있다)
```

> Q. 자바스크립트 규격은 ECMA Script는 es6 버전부터 페러다임적 변화가 있었다. es6 전과 후의 버전은 무엇이 달라졌는지 서술해보자.
> 

```
A.
**let, const 키워드의 추가**: 블록 스코프(지역선언) 변수와 상수의 추가
**화살표 함수의 추가** : 함수를 더 간결하게 작성할 수 있게 합니다.
**클래스 문법이 도입**
**템플릿 리터럴:** 변수나 표현식을 ${} 안에 삽입하여 문자열을 동적으로 구성할 수 있습니다.
**비동기 프로그래밍 (Promises, async/await) 도입** :Promise는 비동기 작업을 다루기 위한 객체로 대기, 이행, 거부 세가지 상태가 있다.
async는 비동기로 작동할 수 있게 해주는 문법이며 await는 비동기작업이 완료될 때까지 기다렸다가(어떤 작업이 끝나야 실행되는지) 실행하도록하는 기능입니다
```

> Q. SPA란 무엇이고 어떤 특징을 가지고 있고 어떤 역할을 하는지 서술해보자.
> 

```
A.
**SPA(single page application)란?**
SPA는 단일 HTML 페이지로 이루어지며, 페이지를 동적으로 업데이트하고 필요한 데이터를 미리 로드하여 사용자 경험을 향상시키는데 중점을 둔 웹 어플리케이션입니다.

**특징 및 역할**
**단일 페이지**: SPA는 하나의 HTML 페이지로 시작하고, 사용자가 상호작용할 때 동적으로 페이지의 일부만을 업데이트합니다. 전체 페이지를 새로 로드하지 않고도 콘텐츠를 갱신할 수 있어, 빠른 응답 속도와 부드러운 사용자 경험을 제공합니다.

**동적 콘텐츠 로딩**: SPA는 초기에 필요한 최소한의 HTML, CSS, JavaScript를 로드하고, 필요한 데이터는 필요한 시점에 비동기적으로 서버에서 가져와 콘텐츠를 동적으로 업데이트합니다. 이로써 초기 로딩 시간을 최소화하고 필요한 데이터만을 효율적으로 전송합니다.

**루팅 및 네비게이션**: SPA는 브라우저의 주소 표시줄의 변화 없이 루팅을 관리할 수 있습니다. 이는 브라우저 히스토리 관리와 함께 뒤로 가기, 앞으로 가기 등의 네비게이션을 부드럽게 처리할 수 있도록 합니다.

**상태 관리**: SPA에서는 클라이언트 측에서 어플리케이션 상태를 관리하는데, 이는 주로 상태 관리 라이브러리나 프레임워크를 사용하여 이루어집니다. 이를 통해 복잡한 어플리케이션에서 상태의 일관성을 유지하고 데이터를 효율적으로 관리할 수 있습니다.

**사용자 경험 향상**: SPA는 페이지 간 전환이 부드럽고 빠르기 때문에 사용자 경험을 향상시킵니다. 또한, AJAX를 사용하여 필요한 데이터를 비동기적으로 로드하기 때문에 사용자는 페이지 간의 이동 시에 불필요한 대기 시간이 발생하지 않습니다.
```

> Q. 현대에 R-DBMS를 대체할 O-DBMS는 무엇이고 어떤 구조를 가지고 있는지 서술 해보자.
> 

```
A.
**O-DBMS?**
O-DBMS는 데이터를 객체로 표현하고 객체 간의 관계를 중심으로 데이터를 저장하며, 객체지향 프로그래밍의 개념을 데이터베이스에 도입한 형태입니다.

**O-DBMS의 특징과 구조
객체 지향 모델**:
O-DBMS는 관계형 데이터베이스의 테이블과 레코드 대신, 객체라는 개념을 사용하여 데이터를 모델링합니다.
데이터베이스의 기본 단위는 객체이며, 이 객체는 데이터와 해당 데이터를 처리하는 메서드를 함께 포함합니다.
예를 들어, 관계형 데이터베이스에서의 테이블은 O-DBMS에서는 클래스로 표현되고, 테이블의 레코드는 클래스의 객체로 표현됩니다.

**객체 간의 관계**:
객체지향 모델에서는 객체 간의 관계가 중요하게 다뤄집니다. 이를 통해 복잡한 데이터 구조를 표현하고, 객체 간의 상속, 연관, 집합 등 다양한 관계를 표현할 수 있습니다.
이러한 관계는 관계형 데이터베이스의 외래 키와 같은 개념보다 직관적이고 유연합니다.

**메서드와 데이터의 캡슐화**:
O-DBMS에서는 객체에 속한 데이터와 메서드가 함께 저장되어 있습니다. 이는 객체지향 프로그래밍에서의 캡슐화 개념을 반영합니다.
데이터의 상태를 변경하는 메서드는 객체 내부에 존재하고, 외부에서 직접적으로 데이터에 접근하기 보다는 메서드를 통해 상호작용합니다.

**유연성과 확장성**:
O-DBMS는 데이터 모델을 변경하거나 확장하는 데 유연성을 제공합니다. 새로운 속성이나 메서드를 객체에 추가하기가 상대적으로 간단하며, 데이터베이스의 구조를 변경하지 않고도 애플리케이션의 요구사항 변화에 적응할 수 있습니다.

**성능 측면**:
O-DBMS는 특정 상황에서는 R-DBMS보다 빠를 수 있지만, 모든 상황에서 그렇지는 않습니다. 각각의 데이터베이스는 특정 용도나 요구사항에 더 적합한 경우가 있습니다.
```

---

# NodeJS의 이해

- Reference
1. [NodeJS 소개](https://nodejs.org/en/learn/getting-started/introduction-to-nodejs)
2. [Node.js를 설치하는 방법](https://nodejs.org/en/learn/getting-started/how-to-install-nodejs)
3. [Node.js를 사용하려면 얼마나 많은 JavaScript를 알아야 합니까?](https://nodejs.org/en/learn/getting-started/how-much-javascript-do-you-need-to-know-to-use-nodejs)
4. [ECMAScript 2015(ES6)](https://nodejs.org/en/learn/getting-started/ecmascript-2015-es6-and-beyond)
5. [NPM 패키지 관리자 소개](https://nodejs.org/en/learn/getting-started/an-introduction-to-the-npm-package-manager)
6. [Node.js, 개발과 프로덕션의 차이점](https://nodejs.org/en/learn/getting-started/nodejs-the-difference-between-development-and-production)
7. [TypeScript를 사용한 Node.js](https://nodejs.org/en/learn/getting-started/nodejs-with-typescript)
8. [Node.js에서 환경 변수를 읽는 방법](https://nodejs.org/en/learn/command-line/how-to-read-environment-variables-from-nodejs)

---

Q. 비동기 I/O 기본 요소? 비 차단 패러다임?

A. 모든 요청을 한번에 받습니다. 그리고 순서와 상관없이 처리 속도가 빠른 것부터 결과를 가져다줍니다. 처리 속도가 빠른 것부터 처리하기 때문에 요청을 놓치지 않고, 4번째 손님이 굳이 3번째 손님의 요청이 끝날 때까지 기다리는 문제도 사라졌습니다.

이게 Node.js의**Non-blocking I/O**의 개념입니다.

---

Q 동기? 비동기?라는 단어가 너무 많이 나와ㅜㅜ 왜??

자바스크립트의 성격?

동기적(Synchronous) 및 비동기적(Asynchronous) 프로그래밍을 모두 지원하는 언어입니다.

- ?
    
    근데 자바스크립트는 단일 쓰레드로 동작
    
    단일쓰레드는 직업을 차례로 처리
    
    단일 쓰레드?
    
    단일 쓰레드는 한 번에 하나의 작업만을 처리할 수 있는 쓰레드(Thread) 모델을 의미합니다.
    
     쓰레드는 운영체제에서 제공하는 가장 작은 실행 단위로, 프로그램이 동시에 여러 작업을 처리할 수 있게 합니다. 따라서 단일 쓰레드는 동시에 하나의 작업만을 처리하며, 다른 작업은 차례로 처리됩니다.
    
    단일 쓰레드의 특징과 의미는 다음과 같습니다:
    
    1. **순차적 처리:** 한 번에 하나의 작업만을 처리하므로 작업은 순차적으로 실행됩니다. 현재 진행 중인 작업이 완료되어야 다음 작업이 실행됩니다.
    2. **단순성과 안정성:** 단일 쓰레드 모델은 간단하고 안정적이기 때문에 구현이 간단하며 디버깅이 쉽습니다.
    3. **동시성 부재:** 여러 작업을 동시에 처리하지 않기 때문에 동시성이 부재합니다. 이는 여러 작업이 동시에 실행되는 다중 쓰레드 모델과 대조됩니다.
    4. **자원 관리 용이성:** 단일 쓰레드는 자원 관리가 간단하다는 장점이 있습니다. 자원 충돌과 경합 상태 등이 발생할 가능성이 낮습니다.

그래서 비동기적? 방법인 콜백함수 promise등을 사용함

---

Q.setTimeOut과 promise는 무슨차이?

A.

**`setTimeout`**과 **`Promise`**는 JavaScript에서 비동기 프로그래밍을 처리하는 두 가지 다른 메커니즘입니다. 각각의 특징과 차이점에 대해 비교적으로 설명하겠습니다.

1. **`setTimeout`:**
    - **특징:**
        - 주어진 시간(밀리초) 이후에 콜백 함수를 실행하는 함수.
        - 단일 비동기 작업을 처리하며, 특정 시간이 지난 후에 코드를 실행하고자 할 때 사용.
    - **예시:**
        
        ```jsx
        javascriptCopy code
        console.log('Start');
        
        setTimeout(() => {
          console.log('Inside setTimeout callback');
        }, 1000);
        
        console.log('End');
        
        ```
        
    - **결과:**
        
        ```scss
        scssCopy code
        Start
        End
        Inside setTimeout callback (1초 후)
        
        ```
        
    - **차이점:**
        - **`setTimeout`**은 단일 비동기 작업을 처리하며, 콜백 함수를 인자로 받아 실행됨. 그러나 여러 비동기 작업을 순서대로 실행하기에는 한계가 있음.
2. **`Promise`:**
    - **특징:**
        - 비동기 작업의 성공 또는 실패를 나타내는 객체.
        - 비동기 작업이 완료되면 **`resolve`** 또는 **`reject`** 함수를 호출하여 결과를 반환.
    - **예시:**
        
        ```jsx
        javascriptCopy code
        console.log('Start');
        
        const myPromise = new Promise((resolve, reject) => {
          setTimeout(() => {
            resolve('Promise resolved after 1000ms');
          }, 1000);
        });
        
        myPromise.then((result) => {
          console.log(result);
        });
        
        console.log('End');
        
        ```
        
    - **결과:**
        
        ```sql
        sqlCopy code
        Start
        End
        Promise resolved after 1000ms (1초 후)
        
        ```
        
    - **차이점:**
        - **`Promise`**는 비동기 작업의 성공과 실패를 다루기 위한 패턴을 제공하며, **`then`**과 **`catch`**를 통해 연속적으로 비동기 작업을 처리할 수 있음.
        - 여러 개의 비동기 작업을 연결하여 순서대로 실행할 수 있는 강력한 기능을 제공.

**요약:**

- **`setTimeout`**은 특정 시간이 지난 후에 단일 작업을 실행하는데 사용되며, 주로 시간 지연에 활용됨.
- **`Promise`**는 비동기 작업의 성공과 실패를 다루는 패턴을 제공하며, 여러 작업을 연결하여 비동기 코드를 더 잘 관리할 수 있음.

---

Q. 콜백?

"콜백"은 다른 함수가 실행이 끝난뒤 실행될 함수를 의미합니다.  이것은 주로 비동기적인 상황에서 많이 사용되며, 특히 JavaScript에서는 이벤트 처리, HTTP 요청, 파일 읽기와 같은 비동기 작업에 자주 적용됩니다.

A.

**개념**

1. **함수를 인자로 전달:**
    - JavaScript에서 함수는 일급 객체로 취급되기 때문에 다른 함수에게 매개변수로 전달할 수 있습니다. 이때 전달된 함수가 바로 "콜백"이 됩니다.
2. **비동기 작업의 완료를 처리:**
    - 주로 비동기 작업이 완료되었을 때, 시스템 또는 이벤트 리스너는 등록된 콜백 함수를 호출합니다. 이렇게 함으로써 비동기 작업의 결과나 상태에 대한 처리가 가능해집니다.
3. **이벤트 처리:**
    - 이벤트 기반의 프로그래밍에서 이벤트가 발생했을 때 실행할 함수를 등록하는 것도 콜백의 일종입니다. 이때 등록된 함수가 이벤트가 발생했을 때 호출되어 특정 동작을 수행합니다.
4. **코드의 구조화와 가독성 향상:**
    - 콜백을 사용하면 비동기 코드를 좀 더 구조적으로 작성할 수 있습니다. 이는 특히 여러 비동기 작업을 순차적이거나 병렬로 실행해야 하는 상황에서 유용합니다.

---

Q. npm pnpm yarn의 차이?

**`npm`**, **`pnpm`**, 그리고 **`yarn`**은 모두 JavaScript 프로젝트를 위한 패키지 매니저로 사용되는 도구입니다. 각각의 차이점을 살펴보겠습니다:

1. **npm (Node Package Manager):**
    - **장점:**
        - Node.js 설치 시 자동으로 함께 제공되기 때문에 추가 설정이 필요 없음.
        - 많은 개발자가 사용하며, npm 레지스트리에는 수많은 패키지가 호스팅되어 있어 원하는 패키지를 쉽게 찾을 수 있음.
    - **단점:**
        - 프로젝트마다 패키지를 각각 설치하기 때문에 저장 공간을 상대적으로 많이 차지함.
        - 패키지 설치 시 의존성 문제가 발생할 수 있음.
2. **pnpm:**
    - **장점:**
        - 패키지를 효율적으로 관리하여 저장 공간을 절약함.
        - 여러 프로젝트 간에 패키지를 공유하여 설치 시간과 저장 공간을 최적화함.
    - **단점:**
        - **대규모 프로젝트에서 의존성 복잡성:** 대규모 프로젝트에서 의존성이 복잡하고 많은 경우, pnpm이 npm보다 느릴 수 있습니다. 이는 특히 의존성 그래프가 크고 복잡한 프로젝트에서 발생할 수 있는 문제입니다.
        - **일부 플러그인이나 도구 호환성:** 특정 프로젝트에서는 pnpm을 지원하지 않는 플러그인이나 도구가 있을 수 있습니다. 예를 들어, 일부 특정 빌드 시스템이나 CI/CD 도구에서는 pnpm을 지원하지 않을 수 있습니다.
3. **yarn:**
    - **장점:**
        - npm보다 빠른 설치 속도와 효율적인 의존성 해결을 제공.
        - **`yarn.lock`** 파일을 통해 프로젝트에 정확한 패키지 버전을 고정할 수 있어 의존성 버전 관리가 용이함.
        - 보안 취약점을 자동으로 검사하고 해결할 수 있는 기능을 제공.
    - **단점:**
        - 저장 공간을 더 많이 차지할 수 있음.

**요약:**

- **`npm`**: 간편하게 사용 가능하고, 많은 패키지가 레지스트리에 있어 개발자들 사이에서 널리 사용됨. 단, 의존성 문제와 저장 공간 문제가 있을 수 있음.
- **`pnpm`**: 저장 공간을 효율적으로 사용하며, 여러 프로젝트 간에 패키지를 공유하여 성능을 최적화함. 다만 특정 프로젝트에서는 다른 패키지 매니저보다 떨어질 수 있음.
- **`yarn`**: npm의 단점을 보완하고 더 빠르고 안전한 패키지 관리를 제공함. 의존성 관리가 용이하지만 저장 공간을 더 많이 차지할 수 있음.

Q 프레임워크? 라이브러리?